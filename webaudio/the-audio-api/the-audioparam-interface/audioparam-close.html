<!DOCTYPE html>
<html>
  <head>
    <title>Test AudioParam events very close in time</title>
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src="/webaudio/resources/audit-util.js"></script>
  </head>

  <body>
    <script>
      // Largest supported sample rate that is a power of two to reduce
      // rounding error.
      const sampleRate = 65536;

      // Only one render quantum needed.
      const testFrames = 128;

      // Maximum single-precision float
      const floatMax = Math.fround(3.4028234663852886e38);

      // Epsilon values to test edge rounding precision
      // smallest x such that 1 + x != 1
      const epspos = 1.1102230246251568e-16;
      // smallest x such that 1 - x != 1
      const epsneg = 5.551115123125784e-17;

      promise_test(async t => {
        const context = new OfflineAudioContext({
          numberOfChannels: 1,
          sampleRate,
          length: testFrames
        });

        const src0 = new ConstantSourceNode(context, {offset: 0});
        src0.connect(context.destination);

        const time1 = 0;
        const value1 = 10;

        // Values for the second event (linearRamp).  |value2| must be huge,
        // and |time2| must be small enough that 1/|time2| overflows a
        // single float. This value is the least positive single float.
        const time2 = 1.401298464324817e-45;
        const value2 = floatMax;

        // Schedule automation events
        src0.offset.setValueAtTime(value1, time1);
        src0.offset.linearRampToValueAtTime(value2, time2);

        src0.start();

        const renderedBuffer = await context.startRendering();
        const output = renderedBuffer.getChannelData(0);

        // First frame must match setValueAtTime value
        assert_equals(
            output[0], value1, 'Frame 0 should equal initial value set');

        // Subsequent frames must stabilize at final ramp value
        assert_array_constant_value(
            output.slice(1),
            value2,
            'Frames 1+ should equal ramp target value');
      }, 'NaN should not occur during extreme linearRampToValueAtTime events');

      promise_test(async t => {
        const context = new OfflineAudioContext({
          numberOfChannels: 1,
          sampleRate,
          length: testFrames
        });

        const src1 = new ConstantSourceNode(context, {offset: 0});
        src1.connect(context.destination);

        const frameIndex = 1;

        // These time values are arranged so that time1 < frame/sampleRate <
        // time2.  This means we need to interpolate to get a value at given
        // frame.
        //
        // The values are not so important, but |value2| should be huge.
        const time1 = frameIndex * (1 - epsneg) / context.sampleRate;
        const value1 = 1e15;

        const time2 = frameIndex * (1 + epspos) / context.sampleRate;
        const value2 = floatMax;

        src1.offset.setValueAtTime(value1, time1);
        src1.offset.linearRampToValueAtTime(value2, time2);

        src1.start();

        const renderedBuffer = await context.startRendering();
        const output = renderedBuffer.getChannelData(0);

        // output[0] must still be 0 because automation starts after time 0
        assert_equals(
            output[0], 0, 'output[0] should be 0 before any automation');

        // output[1] should be interpolated
        const sampleTime = frameIndex / context.sampleRate;
        const interpolated =
            value1 + (value2 - value1) * (sampleTime - time1) / (time2 - time1);
        assert_approx_equals(
            output[1],
            interpolated, 0,
            'Interpolated value at frame 1 should match ramp');

        // output[2+] should be constant at value2
        assert_array_constant_value(
            output.slice(2), value2, 'output[2:] should be constant at value2');
      }, 'Interpolation of linear ramp between very close time values');
    </script>
  </body>
</html>
